{"version":3,"file":"data-fns.cjs.production.min.js","sources":["../src/lib/getItem.ts","../src/lib/cyclic.ts","../src/lib/cellularAutomata.ts","../src/lib/euclideanSequencer.ts","../src/lib/binaryToIndices.ts","../src/lib/euclideanSilences.ts","../src/lib/generateSequence.ts","../src/lib/indicesToBinary.ts","../src/lib/mapAt.ts","../src/lib/modulo.ts","../src/lib/palindrome.ts","../src/lib/patternChunks.ts","../src/lib/times.ts"],"sourcesContent":["/**\n * Gets an item from an array based on a mapped index.\n * @param index The index of the item to get.\n * @param array The array to get the item from.\n * @param indexMapFn A function that maps the index to a new index.\n * @returns The item at the mapped index in the array.\n * @example\n * const array = ['a', 'b', 'c', 'd', 'e']\n * const indexMapFn = (index, length) => (index * 2) % length\n * getItem(2, array, indexMapFn)\n * // Returns 'e'\n */\nexport const getItem = <T>(\n  index: number,\n  array: Array<T>,\n  indexMapFn: (index: number, length: number) => number\n): T => {\n  // Map the index to a new index using the indexMapFn function\n  const mappedIndex = indexMapFn(index, array.length)\n\n  // Return the item at the mapped index in the array\n  return array[mappedIndex]\n}\n","/**\n * Maps an index to a cyclic pattern.\n * @param index The original index.\n * @param length The length of the sequence.\n * @returns The mapped index in the cyclic pattern.\n * @example\n * cyclic(6, 5)\n * // Returns 1\n */\nexport const cyclic = (index: number, length: number): number => {\n  // Calculate the mapped index based on the cyclic pattern\n  const normalizedIndex = index % length\n  return Math.abs(normalizedIndex >= 0 ? normalizedIndex : length + normalizedIndex)\n}\n","import { cyclic } from './cyclic'\n\nexport type CellularAutomataRuleset = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number\n]\n// a common rule that generates an interesting balance between chaos and order\nconst ruleset110: CellularAutomataRuleset = [0, 1, 1, 1, 1, 0, 0, 0]\n\nexport type BoundaryFunction = (index: number, length: number) => number\n\n/**\n * Generates a new sequence using a one-dimensional cellular automaton.\n * @param sequence The initial sequence.\n * @param ruleset The ruleset for the cellular automaton.\n * @param boundaryFn The boundary function to use.\n * @returns The resulting sequence.\n * @example\n *\n * generateSequence(10, sequence, cellularAutomata)\n * // Returns [\n * //  [0, 0, 0, 0, 1, 0, 0, 0],\n * //  [0, 0, 0, 1, 1, 1, 0, 0],\n * //  [0, 0, 1, 1, 0, 0, 1, 0],\n * //  [0, 1, 1, 0, 1, 1, 1, 1],\n * //  [0, 1, 0, 0, 1, 0, 0, 0],\n * //  [1, 1, 1, 1, 1, 1, 0, 0],\n * //  [1, 0, 0, 0, 0, 0, 1, 1],\n * //  [0, 1, 0, 0, 0, 1, 1, 0],\n * //  [1, 1, 1, 0, 1, 1, 0, 1],\n * //  [0, 0, 0, 0, 1, 0, 0, 1],\n * // ]\n *\n * @complexity This function has a time complexity of O(n), where n is the length of the input sequence, and\n * a space complexity of O(n), where n is the length of the input sequence.\n */\nexport const cellularAutomata = (\n  sequence: Array<number>,\n  ruleset: CellularAutomataRuleset = ruleset110,\n  boundaryFn: BoundaryFunction = cyclic\n): Array<number> => {\n  const nextSequence = new Array(sequence.length)\n  const len = sequence.length\n\n  // Apply the ruleset to each cell in the sequence\n  for (let i = 0; i < len; i++) {\n    const left = sequence[boundaryFn(i - 1, len)]\n    const middle = sequence[i]\n    const right = sequence[boundaryFn(i + 1, len)]\n    nextSequence[i] = ruleset[left * 4 + middle * 2 + right]\n  }\n\n  return nextSequence\n}\n","const numSort = (a: number, b: number) => a - b\n\n/**\n * Generates a Euclidean rhythm sequence.\n * @param steps The number of steps in the sequence.\n * @param notes The number of notes in the sequence.\n * @param rotation The rotation of the sequence (default: 0).\n * @returns An array of indices representing the Euclidean rhythm sequence.\n * @example\n * euclideanSequencer(8, 3, 1)\n * // Returns [1, 3, 6]\n */\nexport const euclideanSequencer = (steps: number, notes: number, rotation = 0): Array<number> => {\n  // Check that inputs are positive integers\n  if (steps < 0 || notes < 0) {\n    throw new Error('Inputs must be positive integers')\n  }\n\n  // Initialize an empty sequence array\n  const sequence: Array<number> = []\n\n  // Determine the maximum number of notes in the sequence\n  const maxNotes = notes > steps ? steps : notes\n\n  // Iterate through the number of notes and calculate the index for each note\n  for (let i = 0; i < maxNotes; i++) {\n    const index = Math.floor((i * steps) / maxNotes) // Calculate the index using the Euclidean algorithm\n    sequence.push((index + rotation) % steps) // Add the index to the sequence, with rotation applied\n  }\n\n  // Sort the sequence in ascending order\n  return sequence.sort(numSort)\n}\n","/**\n * Converts an array of binary digits to an array of indices where the digit is 1.\n * @param binary An array of binary digits (0 or 1).\n * @returns An array of indices where the digit is 1.\n * @example\n * binaryToIndices([1, 0, 1, 1, 0, 1])\n * // Returns [0, 2, 3, 5]\n *\n * binaryToIndices([1, 1, 1, 1, 1])\n * // Returns [0, 1, 2, 3, 4]\n *\n * binaryToIndices([0, 0, 0, 0, 0])\n * // Returns []\n *\n */\nexport const binaryToIndices = (binary: Array<number>): Array<number> => {\n  // Initialize an empty array to store the indices.\n  const indices: Array<number> = []\n\n  // Loop through the binary array.\n  for (let i = 0; i < binary.length; i++) {\n    // If the digit is 1, add the index to the indices array.\n    if (binary[i] === 1) {\n      indices.push(i)\n    }\n  }\n\n  // Return the array of indices.\n  return indices\n}\n","import { euclideanSequencer } from './euclideanSequencer'\n\n/**\n * Generates a sequence of indices representing the \"silences\" (i.e. rests) in a Euclidean rhythm.\n * @param steps The number of steps in the rhythm.\n * @param notes The number of notes in the rhythm.\n * @param rotation The rotation of the rhythm (default: 0).\n * @returns An array of indices representing the silences in the Euclidean rhythm.\n * @example\n * euclideanSilences(8, 3)\n * // Returns [1, 3, 4, 6, 7]\n */\nexport const euclideanSilences = (steps: number, notes: number, rotation = 0): Array<number> => {\n  // Generate the Euclidean rhythm sequence using the euclideanSequencer function\n  const noteSequence = euclideanSequencer(steps, notes, rotation)\n\n  // Initialize an empty silence sequence array\n  const silenceSequence: Array<number> = []\n\n  // Iterate through each step in the rhythm and add the index to the silence sequence if it is not in the note sequence\n  for (let i = 0; i < steps; i++) {\n    if (!noteSequence.includes(i)) {\n      silenceSequence.push(i)\n    }\n  }\n\n  // Return the silence sequence\n  return silenceSequence\n}\n","/**\n * Generates a sequence of values by applying a given function to an initial value for a specified number of iterations.\n * @param iterations The number of iterations to perform.\n * @param initialValue The initial value of the sequence.\n * @param iteratorFn The function to apply to the initial value and each subsequent value.\n * @returns An array containing all the iterations.\n * @example\n * generateSequence(5, 1, (value) => value * 2)\n * // Returns [1, 2, 4, 8, 16]\n */\nexport const generateSequence = <T>(\n  iterations: number,\n  initialValue: T,\n  iteratorFn: (value: T) => T\n): T[] => {\n  if (iterations < 0) {\n    throw new Error('Iterations must be a positive number')\n  }\n\n  if (iterations === 0) {\n    return []\n  }\n\n  const sequence: T[] = [initialValue]\n  let value = initialValue\n\n  for (let i = 1; i < iterations; i++) {\n    value = iteratorFn(value)\n    sequence.push(value)\n  }\n\n  return sequence\n}\n","/**\n * Converts an array of indices to a binary array where the indices are 1 and the other digits are 0.\n * @param indices An array of indices.\n * @param length The length of the binary array to be returned.\n * @returns A binary array where the indices are 1 and the other digits are 0.\n * @example\n * // Basic usage\n * indicesToBinary([0, 2, 4], 5)\n * // Returns [1, 0, 1, 0, 1]\n *\n * // Ignoring negative indices\n * indicesToBinary([0, -1, 2, -2, 4], 5)\n * // Returns [1, 0, 1, 0, 1]\n *\n * // Indices outside range are ignored\n * indicesToBinary([0, 2, 4, 6], 5)\n * // Returns [1, 0, 1, 0, 1]\n */\nexport const indicesToBinary = (indices: Array<number>, length: number): Array<number> => {\n  // Initialize a binary array of the given length, filled with 0s.\n  const binary: Array<number> = Array(length).fill(0)\n\n  // Loop through the indices array.\n  for (const index of indices) {\n    // Ignore negative indices.\n    if (index >= 0) {\n      // If the index is within range, set the corresponding digit to 1.\n      if (index < length) {\n        binary[index] = 1\n      }\n    }\n  }\n\n  // Return the binary array.\n  return binary\n}\n","/**\n * Maps an item in an array at a specified index to a new value.\n * @param array The array to map the item in.\n * @param index The index of the item to map.\n * @param mapFn A function that maps the item to a new value.\n * @returns A new array with the mapped item.\n * @example\n * const originalArray = [1, 2, 3, 4, 5]\n * const mappedArray = mapAt(originalArray, 2, (item) => item * 2)\n * // Returns [1, 2, 6, 4, 5]\n */\nexport const mapAt = <T>(array: Array<T>, index: number, mapFn: (item: T) => T): Array<T> => {\n  // Check that the index is within the bounds of the array\n  if (index > array.length || index < 0) {\n    throw new Error('Index out of range')\n  }\n\n  // Get the item at the specified index\n  const item = array[index]\n\n  // Map the item to a new value using the mapFn function\n  const newItem = mapFn(item)\n\n  // If the new value is the same as the original value, return the original array\n  if (newItem === item) {\n    return array\n  }\n\n  // Create a new array with the mapped item\n  const newArray = array.slice()\n  newArray[index] = mapFn(array[index])\n\n  return newArray\n}\n","/**\n * Returns the remainder of dividing the dividend by the divisor, with support for negative dividends.\n * @param dividend The dividend to divide.\n * @param divisor The divisor to divide by.\n * @returns The remainder of dividing the dividend by the divisor.\n * @example\n * // Basic usage\n * modulo(5, 3)\n * // Returns 2\n *\n * // Support for negative dividends\n * modulo(-5, -3)\n * // Returns 2\n *\n * // Support for negative divisors\n * modulo(-5, 3)\n * // Returns -2\n *\n * // Support for negative dividends and divisors\n * modulo(5, -3)\n * // Returns -2\n *\n */\nexport const modulo = (dividend: number, divisor: number): number => {\n  // Compute the remainder of dividing the absolute value of the dividend by the absolute value of the divisor.\n  const remainder = Math.abs(dividend) % Math.abs(divisor)\n\n  // Compute the sign of the result based on the sign of the dividend and divisor.\n  const sign = Math.sign(dividend) * Math.sign(divisor)\n\n  // Compute the result by adjusting the remainder based on the sign.\n  const result = remainder * sign\n\n  // Return the result.\n  return result\n}\n","/**\n * Maps an index to a palindrome pattern.\n * @param index The original index.\n * @param length The length of the sequence.\n * @returns The mapped index in the palindrome pattern.\n * @example\n * const length = 5\n * const indexes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n * indexes.map((index) => palindrome(index, length))\n * // Returns [0, 1, 2, 1, 0, 1, 2, 1, 0, 1]\n */\nexport const palindrome = (index: number, length: number): number => {\n  // Save the length of the sequence in a variable\n  const arraySize = length\n\n  // If the sequence has only one element, return 0\n  if (arraySize === 1) {\n    return 0\n  }\n\n  // Calculate the mapped index based on the palindrome pattern\n  const normalizedIndex = index % (2 * arraySize - 2)\n  const id = normalizedIndex >= 0 ? normalizedIndex : 2 * arraySize - 2 + normalizedIndex\n\n  if (id < arraySize) {\n    return Math.abs(id)\n  } else {\n    return 2 * arraySize - id - 2\n  }\n}\n","import { cyclic } from './cyclic'\nimport { getItem } from './getItem'\n\n/**\n * Splits an array into chunks based on a pattern.\n * @param array The array to split.\n * @param pattern The pattern to split the array with.\n * @returns An array of arrays representing the splits.\n * @example\n * patternChunks([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3])\n * // Returns [[1], [2, 3], [4, 5, 6], [7], [8]]\n *\n * @remarks\n * This function splits the input array into chunks based on the specified pattern. The pattern is an array of\n * numbers that determines the size of each chunk. If the pattern is shorter than the input array, it will be\n * repeated cyclically. If the pattern is longer than the input array, the remaining elements will be discarded.\n */\nexport const patternChunks = <T>(array: Array<T>, pattern: Array<number>): Array<Array<T>> => {\n  const result: Array<Array<T>> = []\n  const _array = [...array]\n  let i = 0\n\n  while (_array.length > 0) {\n    result.push(_array.splice(0, getItem(i, pattern, cyclic)))\n    i++\n  }\n\n  return result\n}\n","/**\n * Calls a callback function a specified number of times and returns the results in an array.\n * @param iterations The number of times to call the callback function.\n * @param callback The callback function to call.\n * @returns An array containing the results of each callback function call.\n * @example\n * times(5, (i) => i * 2)\n * // Returns [0, 2, 4, 6, 8]\n *\n */\nexport const times = <T>(iterations: number, callback: (index: number) => T): Array<T> => {\n  // Initialize an empty array to store the results\n  const result: Array<T> = []\n\n  // Loop `iterations` number of times, calling the callback function on each iteration\n  for (let i = 0; i < iterations; i++) {\n    // Call the callback function with the current index and push the result to the results array\n    result.push(callback(i))\n  }\n\n  // Return the results array\n  return result\n}\n"],"names":["getItem","index","array","indexMapFn","length","cyclic","normalizedIndex","Math","abs","ruleset110","numSort","a","b","euclideanSequencer","steps","notes","rotation","Error","sequence","maxNotes","i","floor","push","sort","binary","indices","ruleset","boundaryFn","nextSequence","Array","len","left","middle","right","noteSequence","silenceSequence","includes","iterations","initialValue","iteratorFn","value","fill","mapFn","item","newArray","slice","dividend","divisor","sign","arraySize","id","pattern","result","_array","splice","callback"],"mappings":"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"}