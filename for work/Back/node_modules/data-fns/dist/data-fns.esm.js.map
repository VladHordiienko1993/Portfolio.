{"version":3,"file":"data-fns.esm.js","sources":["../src/lib/times.ts","../src/lib/mapAt.ts","../src/lib/getItem.ts","../src/lib/generateSequence.ts","../src/lib/cyclic.ts","../src/lib/palindrome.ts","../src/lib/modulo.ts","../src/lib/cellularAutomata.ts","../src/lib/euclideanSequencer.ts","../src/lib/euclideanSilences.ts","../src/lib/patternChunks.ts","../src/lib/binaryToIndices.ts","../src/lib/indicesToBinary.ts"],"sourcesContent":["/**\n * Calls a callback function a specified number of times and returns the results in an array.\n * @param iterations The number of times to call the callback function.\n * @param callback The callback function to call.\n * @returns An array containing the results of each callback function call.\n * @example\n * times(5, (i) => i * 2)\n * // Returns [0, 2, 4, 6, 8]\n *\n */\nexport const times = <T>(iterations: number, callback: (index: number) => T): Array<T> => {\n  // Initialize an empty array to store the results\n  const result: Array<T> = []\n\n  // Loop `iterations` number of times, calling the callback function on each iteration\n  for (let i = 0; i < iterations; i++) {\n    // Call the callback function with the current index and push the result to the results array\n    result.push(callback(i))\n  }\n\n  // Return the results array\n  return result\n}\n","/**\n * Maps an item in an array at a specified index to a new value.\n * @param array The array to map the item in.\n * @param index The index of the item to map.\n * @param mapFn A function that maps the item to a new value.\n * @returns A new array with the mapped item.\n * @example\n * const originalArray = [1, 2, 3, 4, 5]\n * const mappedArray = mapAt(originalArray, 2, (item) => item * 2)\n * // Returns [1, 2, 6, 4, 5]\n */\nexport const mapAt = <T>(array: Array<T>, index: number, mapFn: (item: T) => T): Array<T> => {\n  // Check that the index is within the bounds of the array\n  if (index > array.length || index < 0) {\n    throw new Error('Index out of range')\n  }\n\n  // Get the item at the specified index\n  const item = array[index]\n\n  // Map the item to a new value using the mapFn function\n  const newItem = mapFn(item)\n\n  // If the new value is the same as the original value, return the original array\n  if (newItem === item) {\n    return array\n  }\n\n  // Create a new array with the mapped item\n  const newArray = array.slice()\n  newArray[index] = mapFn(array[index])\n\n  return newArray\n}\n","/**\n * Gets an item from an array based on a mapped index.\n * @param index The index of the item to get.\n * @param array The array to get the item from.\n * @param indexMapFn A function that maps the index to a new index.\n * @returns The item at the mapped index in the array.\n * @example\n * const array = ['a', 'b', 'c', 'd', 'e']\n * const indexMapFn = (index, length) => (index * 2) % length\n * getItem(2, array, indexMapFn)\n * // Returns 'e'\n */\nexport const getItem = <T>(\n  index: number,\n  array: Array<T>,\n  indexMapFn: (index: number, length: number) => number\n): T => {\n  // Map the index to a new index using the indexMapFn function\n  const mappedIndex = indexMapFn(index, array.length)\n\n  // Return the item at the mapped index in the array\n  return array[mappedIndex]\n}\n","/**\n * Generates a sequence of values by applying a given function to an initial value for a specified number of iterations.\n * @param iterations The number of iterations to perform.\n * @param initialValue The initial value of the sequence.\n * @param iteratorFn The function to apply to the initial value and each subsequent value.\n * @returns An array containing all the iterations.\n * @example\n * generateSequence(5, 1, (value) => value * 2)\n * // Returns [1, 2, 4, 8, 16]\n */\nexport const generateSequence = <T>(\n  iterations: number,\n  initialValue: T,\n  iteratorFn: (value: T) => T\n): T[] => {\n  if (iterations < 0) {\n    throw new Error('Iterations must be a positive number')\n  }\n\n  if (iterations === 0) {\n    return []\n  }\n\n  const sequence: T[] = [initialValue]\n  let value = initialValue\n\n  for (let i = 1; i < iterations; i++) {\n    value = iteratorFn(value)\n    sequence.push(value)\n  }\n\n  return sequence\n}\n","/**\n * Maps an index to a cyclic pattern.\n * @param index The original index.\n * @param length The length of the sequence.\n * @returns The mapped index in the cyclic pattern.\n * @example\n * cyclic(6, 5)\n * // Returns 1\n */\nexport const cyclic = (index: number, length: number): number => {\n  // Calculate the mapped index based on the cyclic pattern\n  const normalizedIndex = index % length\n  return Math.abs(normalizedIndex >= 0 ? normalizedIndex : length + normalizedIndex)\n}\n","/**\n * Maps an index to a palindrome pattern.\n * @param index The original index.\n * @param length The length of the sequence.\n * @returns The mapped index in the palindrome pattern.\n * @example\n * const length = 5\n * const indexes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n * indexes.map((index) => palindrome(index, length))\n * // Returns [0, 1, 2, 1, 0, 1, 2, 1, 0, 1]\n */\nexport const palindrome = (index: number, length: number): number => {\n  // Save the length of the sequence in a variable\n  const arraySize = length\n\n  // If the sequence has only one element, return 0\n  if (arraySize === 1) {\n    return 0\n  }\n\n  // Calculate the mapped index based on the palindrome pattern\n  const normalizedIndex = index % (2 * arraySize - 2)\n  const id = normalizedIndex >= 0 ? normalizedIndex : 2 * arraySize - 2 + normalizedIndex\n\n  if (id < arraySize) {\n    return Math.abs(id)\n  } else {\n    return 2 * arraySize - id - 2\n  }\n}\n","/**\n * Returns the remainder of dividing the dividend by the divisor, with support for negative dividends.\n * @param dividend The dividend to divide.\n * @param divisor The divisor to divide by.\n * @returns The remainder of dividing the dividend by the divisor.\n * @example\n * // Basic usage\n * modulo(5, 3)\n * // Returns 2\n *\n * // Support for negative dividends\n * modulo(-5, -3)\n * // Returns 2\n *\n * // Support for negative divisors\n * modulo(-5, 3)\n * // Returns -2\n *\n * // Support for negative dividends and divisors\n * modulo(5, -3)\n * // Returns -2\n *\n */\nexport const modulo = (dividend: number, divisor: number): number => {\n  // Compute the remainder of dividing the absolute value of the dividend by the absolute value of the divisor.\n  const remainder = Math.abs(dividend) % Math.abs(divisor)\n\n  // Compute the sign of the result based on the sign of the dividend and divisor.\n  const sign = Math.sign(dividend) * Math.sign(divisor)\n\n  // Compute the result by adjusting the remainder based on the sign.\n  const result = remainder * sign\n\n  // Return the result.\n  return result\n}\n","import { cyclic } from './cyclic'\n\nexport type CellularAutomataRuleset = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number\n]\n// a common rule that generates an interesting balance between chaos and order\nconst ruleset110: CellularAutomataRuleset = [0, 1, 1, 1, 1, 0, 0, 0]\n\nexport type BoundaryFunction = (index: number, length: number) => number\n\n/**\n * Generates a new sequence using a one-dimensional cellular automaton.\n * @param sequence The initial sequence.\n * @param ruleset The ruleset for the cellular automaton.\n * @param boundaryFn The boundary function to use.\n * @returns The resulting sequence.\n * @example\n *\n * generateSequence(10, sequence, cellularAutomata)\n * // Returns [\n * //  [0, 0, 0, 0, 1, 0, 0, 0],\n * //  [0, 0, 0, 1, 1, 1, 0, 0],\n * //  [0, 0, 1, 1, 0, 0, 1, 0],\n * //  [0, 1, 1, 0, 1, 1, 1, 1],\n * //  [0, 1, 0, 0, 1, 0, 0, 0],\n * //  [1, 1, 1, 1, 1, 1, 0, 0],\n * //  [1, 0, 0, 0, 0, 0, 1, 1],\n * //  [0, 1, 0, 0, 0, 1, 1, 0],\n * //  [1, 1, 1, 0, 1, 1, 0, 1],\n * //  [0, 0, 0, 0, 1, 0, 0, 1],\n * // ]\n *\n * @complexity This function has a time complexity of O(n), where n is the length of the input sequence, and\n * a space complexity of O(n), where n is the length of the input sequence.\n */\nexport const cellularAutomata = (\n  sequence: Array<number>,\n  ruleset: CellularAutomataRuleset = ruleset110,\n  boundaryFn: BoundaryFunction = cyclic\n): Array<number> => {\n  const nextSequence = new Array(sequence.length)\n  const len = sequence.length\n\n  // Apply the ruleset to each cell in the sequence\n  for (let i = 0; i < len; i++) {\n    const left = sequence[boundaryFn(i - 1, len)]\n    const middle = sequence[i]\n    const right = sequence[boundaryFn(i + 1, len)]\n    nextSequence[i] = ruleset[left * 4 + middle * 2 + right]\n  }\n\n  return nextSequence\n}\n","const numSort = (a: number, b: number) => a - b\n\n/**\n * Generates a Euclidean rhythm sequence.\n * @param steps The number of steps in the sequence.\n * @param notes The number of notes in the sequence.\n * @param rotation The rotation of the sequence (default: 0).\n * @returns An array of indices representing the Euclidean rhythm sequence.\n * @example\n * euclideanSequencer(8, 3, 1)\n * // Returns [1, 3, 6]\n */\nexport const euclideanSequencer = (steps: number, notes: number, rotation = 0): Array<number> => {\n  // Check that inputs are positive integers\n  if (steps < 0 || notes < 0) {\n    throw new Error('Inputs must be positive integers')\n  }\n\n  // Initialize an empty sequence array\n  const sequence: Array<number> = []\n\n  // Determine the maximum number of notes in the sequence\n  const maxNotes = notes > steps ? steps : notes\n\n  // Iterate through the number of notes and calculate the index for each note\n  for (let i = 0; i < maxNotes; i++) {\n    const index = Math.floor((i * steps) / maxNotes) // Calculate the index using the Euclidean algorithm\n    sequence.push((index + rotation) % steps) // Add the index to the sequence, with rotation applied\n  }\n\n  // Sort the sequence in ascending order\n  return sequence.sort(numSort)\n}\n","import { euclideanSequencer } from './euclideanSequencer'\n\n/**\n * Generates a sequence of indices representing the \"silences\" (i.e. rests) in a Euclidean rhythm.\n * @param steps The number of steps in the rhythm.\n * @param notes The number of notes in the rhythm.\n * @param rotation The rotation of the rhythm (default: 0).\n * @returns An array of indices representing the silences in the Euclidean rhythm.\n * @example\n * euclideanSilences(8, 3)\n * // Returns [1, 3, 4, 6, 7]\n */\nexport const euclideanSilences = (steps: number, notes: number, rotation = 0): Array<number> => {\n  // Generate the Euclidean rhythm sequence using the euclideanSequencer function\n  const noteSequence = euclideanSequencer(steps, notes, rotation)\n\n  // Initialize an empty silence sequence array\n  const silenceSequence: Array<number> = []\n\n  // Iterate through each step in the rhythm and add the index to the silence sequence if it is not in the note sequence\n  for (let i = 0; i < steps; i++) {\n    if (!noteSequence.includes(i)) {\n      silenceSequence.push(i)\n    }\n  }\n\n  // Return the silence sequence\n  return silenceSequence\n}\n","import { cyclic } from './cyclic'\nimport { getItem } from './getItem'\n\n/**\n * Splits an array into chunks based on a pattern.\n * @param array The array to split.\n * @param pattern The pattern to split the array with.\n * @returns An array of arrays representing the splits.\n * @example\n * patternChunks([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3])\n * // Returns [[1], [2, 3], [4, 5, 6], [7], [8]]\n *\n * @remarks\n * This function splits the input array into chunks based on the specified pattern. The pattern is an array of\n * numbers that determines the size of each chunk. If the pattern is shorter than the input array, it will be\n * repeated cyclically. If the pattern is longer than the input array, the remaining elements will be discarded.\n */\nexport const patternChunks = <T>(array: Array<T>, pattern: Array<number>): Array<Array<T>> => {\n  const result: Array<Array<T>> = []\n  const _array = [...array]\n  let i = 0\n\n  while (_array.length > 0) {\n    result.push(_array.splice(0, getItem(i, pattern, cyclic)))\n    i++\n  }\n\n  return result\n}\n","/**\n * Converts an array of binary digits to an array of indices where the digit is 1.\n * @param binary An array of binary digits (0 or 1).\n * @returns An array of indices where the digit is 1.\n * @example\n * binaryToIndices([1, 0, 1, 1, 0, 1])\n * // Returns [0, 2, 3, 5]\n *\n * binaryToIndices([1, 1, 1, 1, 1])\n * // Returns [0, 1, 2, 3, 4]\n *\n * binaryToIndices([0, 0, 0, 0, 0])\n * // Returns []\n *\n */\nexport const binaryToIndices = (binary: Array<number>): Array<number> => {\n  // Initialize an empty array to store the indices.\n  const indices: Array<number> = []\n\n  // Loop through the binary array.\n  for (let i = 0; i < binary.length; i++) {\n    // If the digit is 1, add the index to the indices array.\n    if (binary[i] === 1) {\n      indices.push(i)\n    }\n  }\n\n  // Return the array of indices.\n  return indices\n}\n","/**\n * Converts an array of indices to a binary array where the indices are 1 and the other digits are 0.\n * @param indices An array of indices.\n * @param length The length of the binary array to be returned.\n * @returns A binary array where the indices are 1 and the other digits are 0.\n * @example\n * // Basic usage\n * indicesToBinary([0, 2, 4], 5)\n * // Returns [1, 0, 1, 0, 1]\n *\n * // Ignoring negative indices\n * indicesToBinary([0, -1, 2, -2, 4], 5)\n * // Returns [1, 0, 1, 0, 1]\n *\n * // Indices outside range are ignored\n * indicesToBinary([0, 2, 4, 6], 5)\n * // Returns [1, 0, 1, 0, 1]\n */\nexport const indicesToBinary = (indices: Array<number>, length: number): Array<number> => {\n  // Initialize a binary array of the given length, filled with 0s.\n  const binary: Array<number> = Array(length).fill(0)\n\n  // Loop through the indices array.\n  for (const index of indices) {\n    // Ignore negative indices.\n    if (index >= 0) {\n      // If the index is within range, set the corresponding digit to 1.\n      if (index < length) {\n        binary[index] = 1\n      }\n    }\n  }\n\n  // Return the binary array.\n  return binary\n}\n"],"names":["times","iterations","callback","result","i","push","mapAt","array","index","mapFn","length","Error","item","newItem","newArray","slice","getItem","indexMapFn","mappedIndex","generateSequence","initialValue","iteratorFn","sequence","value","cyclic","normalizedIndex","Math","abs","palindrome","arraySize","id","modulo","dividend","divisor","remainder","sign","ruleset110","cellularAutomata","ruleset","boundaryFn","nextSequence","Array","len","left","middle","right","numSort","a","b","euclideanSequencer","steps","notes","rotation","maxNotes","floor","sort","euclideanSilences","noteSequence","silenceSequence","includes","patternChunks","pattern","_array","splice","binaryToIndices","binary","indices","indicesToBinary","fill"],"mappings":"AAAA;;;;;;;;;;IAUaA,KAAK,GAAG,SAARA,KAAQ,CAAIC,UAAJ,EAAwBC,QAAxB;AACnB;AACA,MAAMC,MAAM,GAAa,EAAzB;;AAGA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,UAApB,EAAgCG,CAAC,EAAjC,EAAqC;AACnC;AACAD,IAAAA,MAAM,CAACE,IAAP,CAAYH,QAAQ,CAACE,CAAD,CAApB;AACD;;;AAGD,SAAOD,MAAP;AACD;;ACtBD;;;;;;;;;;;AAWA,IAAaG,KAAK,GAAG,SAARA,KAAQ,CAAIC,KAAJ,EAAqBC,KAArB,EAAoCC,KAApC;AACnB;AACA,MAAID,KAAK,GAAGD,KAAK,CAACG,MAAd,IAAwBF,KAAK,GAAG,CAApC,EAAuC;AACrC,UAAM,IAAIG,KAAJ,CAAU,oBAAV,CAAN;AACD;;;AAGD,MAAMC,IAAI,GAAGL,KAAK,CAACC,KAAD,CAAlB;;AAGA,MAAMK,OAAO,GAAGJ,KAAK,CAACG,IAAD,CAArB;;AAGA,MAAIC,OAAO,KAAKD,IAAhB,EAAsB;AACpB,WAAOL,KAAP;AACD;;;AAGD,MAAMO,QAAQ,GAAGP,KAAK,CAACQ,KAAN,EAAjB;AACAD,EAAAA,QAAQ,CAACN,KAAD,CAAR,GAAkBC,KAAK,CAACF,KAAK,CAACC,KAAD,CAAN,CAAvB;AAEA,SAAOM,QAAP;AACD,CAtBM;;ACXP;;;;;;;;;;;;AAYA,IAAaE,OAAO,GAAG,SAAVA,OAAU,CACrBR,KADqB,EAErBD,KAFqB,EAGrBU,UAHqB;AAKrB;AACA,MAAMC,WAAW,GAAGD,UAAU,CAACT,KAAD,EAAQD,KAAK,CAACG,MAAd,CAA9B;;AAGA,SAAOH,KAAK,CAACW,WAAD,CAAZ;AACD,CAVM;;ACZP;;;;;;;;;;AAUA,IAAaC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAC9BlB,UAD8B,EAE9BmB,YAF8B,EAG9BC,UAH8B;AAK9B,MAAIpB,UAAU,GAAG,CAAjB,EAAoB;AAClB,UAAM,IAAIU,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,MAAIV,UAAU,KAAK,CAAnB,EAAsB;AACpB,WAAO,EAAP;AACD;;AAED,MAAMqB,QAAQ,GAAQ,CAACF,YAAD,CAAtB;AACA,MAAIG,KAAK,GAAGH,YAAZ;;AAEA,OAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,UAApB,EAAgCG,CAAC,EAAjC,EAAqC;AACnCmB,IAAAA,KAAK,GAAGF,UAAU,CAACE,KAAD,CAAlB;AACAD,IAAAA,QAAQ,CAACjB,IAAT,CAAckB,KAAd;AACD;;AAED,SAAOD,QAAP;AACD,CAtBM;;ACVP;;;;;;;;;AASA,IAAaE,MAAM,GAAG,SAATA,MAAS,CAAChB,KAAD,EAAgBE,MAAhB;AACpB;AACA,MAAMe,eAAe,GAAGjB,KAAK,GAAGE,MAAhC;AACA,SAAOgB,IAAI,CAACC,GAAL,CAASF,eAAe,IAAI,CAAnB,GAAuBA,eAAvB,GAAyCf,MAAM,GAAGe,eAA3D,CAAP;AACD,CAJM;;ACTP;;;;;;;;;;;AAWA,IAAaG,UAAU,GAAG,SAAbA,UAAa,CAACpB,KAAD,EAAgBE,MAAhB;AACxB;AACA,MAAMmB,SAAS,GAAGnB,MAAlB;;AAGA,MAAImB,SAAS,KAAK,CAAlB,EAAqB;AACnB,WAAO,CAAP;AACD;;;AAGD,MAAMJ,eAAe,GAAGjB,KAAK,IAAI,IAAIqB,SAAJ,GAAgB,CAApB,CAA7B;AACA,MAAMC,EAAE,GAAGL,eAAe,IAAI,CAAnB,GAAuBA,eAAvB,GAAyC,IAAII,SAAJ,GAAgB,CAAhB,GAAoBJ,eAAxE;;AAEA,MAAIK,EAAE,GAAGD,SAAT,EAAoB;AAClB,WAAOH,IAAI,CAACC,GAAL,CAASG,EAAT,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAID,SAAJ,GAAgBC,EAAhB,GAAqB,CAA5B;AACD;AACF,CAlBM;;ACXP;;;;;;;;;;;;;;;;;;;;;;;AAuBA,IAAaC,MAAM,GAAG,SAATA,MAAS,CAACC,QAAD,EAAmBC,OAAnB;AACpB;AACA,MAAMC,SAAS,GAAGR,IAAI,CAACC,GAAL,CAASK,QAAT,IAAqBN,IAAI,CAACC,GAAL,CAASM,OAAT,CAAvC;;AAGA,MAAME,IAAI,GAAGT,IAAI,CAACS,IAAL,CAAUH,QAAV,IAAsBN,IAAI,CAACS,IAAL,CAAUF,OAAV,CAAnC;;AAGA,MAAM9B,MAAM,GAAG+B,SAAS,GAAGC,IAA3B;;AAGA,SAAOhC,MAAP;AACD,CAZM;;ACVP,IAAMiC,UAAU,GAA4B,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAA5C;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,IAAaC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAC9Bf,QAD8B,EAE9BgB,OAF8B,EAG9BC,UAH8B;MAE9BD;AAAAA,IAAAA,UAAmCF;;;MACnCG;AAAAA,IAAAA,aAA+Bf;;;AAE/B,MAAMgB,YAAY,GAAG,IAAIC,KAAJ,CAAUnB,QAAQ,CAACZ,MAAnB,CAArB;AACA,MAAMgC,GAAG,GAAGpB,QAAQ,CAACZ,MAArB;;AAGA,OAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,GAApB,EAAyBtC,CAAC,EAA1B,EAA8B;AAC5B,QAAMuC,IAAI,GAAGrB,QAAQ,CAACiB,UAAU,CAACnC,CAAC,GAAG,CAAL,EAAQsC,GAAR,CAAX,CAArB;AACA,QAAME,MAAM,GAAGtB,QAAQ,CAAClB,CAAD,CAAvB;AACA,QAAMyC,KAAK,GAAGvB,QAAQ,CAACiB,UAAU,CAACnC,CAAC,GAAG,CAAL,EAAQsC,GAAR,CAAX,CAAtB;AACAF,IAAAA,YAAY,CAACpC,CAAD,CAAZ,GAAkBkC,OAAO,CAACK,IAAI,GAAG,CAAP,GAAWC,MAAM,GAAG,CAApB,GAAwBC,KAAzB,CAAzB;AACD;;AAED,SAAOL,YAAP;AACD,CAjBM;;AC1CP,IAAMM,OAAO,GAAG,SAAVA,OAAU,CAACC,CAAD,EAAYC,CAAZ;AAAA,SAA0BD,CAAC,GAAGC,CAA9B;AAAA,CAAhB;AAEA;;;;;;;;;;;;AAUA,IAAaC,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,KAAD,EAAgBC,KAAhB,EAA+BC,QAA/B;MAA+BA;AAAAA,IAAAA,WAAW;;;AAC1E;AACA,MAAIF,KAAK,GAAG,CAAR,IAAaC,KAAK,GAAG,CAAzB,EAA4B;AAC1B,UAAM,IAAIxC,KAAJ,CAAU,kCAAV,CAAN;AACD;;;AAGD,MAAMW,QAAQ,GAAkB,EAAhC;;AAGA,MAAM+B,QAAQ,GAAGF,KAAK,GAAGD,KAAR,GAAgBA,KAAhB,GAAwBC,KAAzC;;AAGA,OAAK,IAAI/C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiD,QAApB,EAA8BjD,CAAC,EAA/B,EAAmC;AACjC,QAAMI,KAAK,GAAGkB,IAAI,CAAC4B,KAAL,CAAYlD,CAAC,GAAG8C,KAAL,GAAcG,QAAzB,CAAd,CADiC;;AAEjC/B,IAAAA,QAAQ,CAACjB,IAAT,CAAc,CAACG,KAAK,GAAG4C,QAAT,IAAqBF,KAAnC,EAFiC;AAGlC;;;AAGD,SAAO5B,QAAQ,CAACiC,IAAT,CAAcT,OAAd,CAAP;AACD,CApBM;;ACVP;;;;;;;;;;;AAUA,IAAaU,iBAAiB,GAAG,SAApBA,iBAAoB,CAACN,KAAD,EAAgBC,KAAhB,EAA+BC,QAA/B;MAA+BA;AAAAA,IAAAA,WAAW;;;AACzE;AACA,MAAMK,YAAY,GAAGR,kBAAkB,CAACC,KAAD,EAAQC,KAAR,EAAeC,QAAf,CAAvC;;AAGA,MAAMM,eAAe,GAAkB,EAAvC;;AAGA,OAAK,IAAItD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8C,KAApB,EAA2B9C,CAAC,EAA5B,EAAgC;AAC9B,QAAI,CAACqD,YAAY,CAACE,QAAb,CAAsBvD,CAAtB,CAAL,EAA+B;AAC7BsD,MAAAA,eAAe,CAACrD,IAAhB,CAAqBD,CAArB;AACD;AACF;;;AAGD,SAAOsD,eAAP;AACD,CAhBM;;ACTP;;;;;;;;;;;;;;;AAcA,IAAaE,aAAa,GAAG,SAAhBA,aAAgB,CAAIrD,KAAJ,EAAqBsD,OAArB;AAC3B,MAAM1D,MAAM,GAAoB,EAAhC;;AACA,MAAM2D,MAAM,aAAOvD,KAAP,CAAZ;;AACA,MAAIH,CAAC,GAAG,CAAR;;AAEA,SAAO0D,MAAM,CAACpD,MAAP,GAAgB,CAAvB,EAA0B;AACxBP,IAAAA,MAAM,CAACE,IAAP,CAAYyD,MAAM,CAACC,MAAP,CAAc,CAAd,EAAiB/C,OAAO,CAACZ,CAAD,EAAIyD,OAAJ,EAAarC,MAAb,CAAxB,CAAZ;AACApB,IAAAA,CAAC;AACF;;AAED,SAAOD,MAAP;AACD,CAXM;;ACjBP;;;;;;;;;;;;;;;AAeA,IAAa6D,eAAe,GAAG,SAAlBA,eAAkB,CAACC,MAAD;AAC7B;AACA,MAAMC,OAAO,GAAkB,EAA/B;;AAGA,OAAK,IAAI9D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6D,MAAM,CAACvD,MAA3B,EAAmCN,CAAC,EAApC,EAAwC;AACtC;AACA,QAAI6D,MAAM,CAAC7D,CAAD,CAAN,KAAc,CAAlB,EAAqB;AACnB8D,MAAAA,OAAO,CAAC7D,IAAR,CAAaD,CAAb;AACD;AACF;;;AAGD,SAAO8D,OAAP;AACD,CAdM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfP;;;;;;;;;;;;;;;;;;AAkBA,IAAaC,eAAe,GAAG,SAAlBA,eAAkB,CAACD,OAAD,EAAyBxD,MAAzB;AAC7B;AACA,MAAMuD,MAAM,GAAkBxB,KAAK,CAAC/B,MAAD,CAAL,CAAc0D,IAAd,CAAmB,CAAnB,CAA9B;;AAGA,uDAAoBF,OAApB,wCAA6B;AAAA,QAAlB1D,KAAkB;;AAC3B;AACA,QAAIA,KAAK,IAAI,CAAb,EAAgB;AACd;AACA,UAAIA,KAAK,GAAGE,MAAZ,EAAoB;AAClBuD,QAAAA,MAAM,CAACzD,KAAD,CAAN,GAAgB,CAAhB;AACD;AACF;AACF;;;AAGD,SAAOyD,MAAP;AACD,CAjBM;;;;"}